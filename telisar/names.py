import re
import random


class NameGenerator:
    """
    Base class for random NPC name generators.

    Class Attributes:

        number_of_names (int): the number of names in a full name
        syllable_template (iter): an iterable of syllable templates, one for each name
        syllable_weights (iter): relative weights for number of syllables to include
        data_path (str): path containing language data files

    Instance Methods:

        full_name: return a random full name consisting of one or more individual names
        validate_name: validate a proposed name. You must define this on your subclass.
        format_name: format a list of names for display

    Usage Example:

    Subclass this class and define the validate_name() method:

        > class npc(NameGenerator):
        >     number_of_names = 2
        >     syllable_template = ('c', 'V', 'c'), ('V', 'C')
        >     syllable_weights = [1, 2], [1, 2, 2]
        >
        >    def validate_name(name):
        >        return True
        >
        >npc.name()

        Some Name

    Details:

    Names are generated by combining syllables randomly generated from language graphemes according to templates, each
    containing one or more of the following:

        c - an optional consonant
        C - a required consonant
        v - an optional vowel
        V - a required consonant

    The simplest possible syllable therefore consists of a single grapheme.

    Names can also contain affixes; these are specified by the special template specifier 'a' and 'A'.

    Examples:

        ('c', V')            - a syllable consisting of exactly one vowel, possibly preceeded by a single consonant
        ('C', 'c', 'V', 'v') - a syllable consisting of one or two consonants followed by one or two vowels
        ('a', 'C', 'V')      - a syllable consisting of an optional affix, a consonant and a vowel.

    Name length is determined by the number of syllables, which is chosen at random using relative weights:

        [2, 2, 1] - Names may contain one, two or three syllables, but are half as likely to contain three.
        [0, 1]    - Names must have exactly two syllables

    Multiple templates and weights can be specified for full names consisting of multiple individual names.
    """
    number_of_names = 1
    syllable_template = ()
    syllable_weights = ()
    data_path = 'data'

    def __init__(self):
        self._vowels = {}
        self._consonants = {}
        self._affixes = {}
        self._load_graphemes()

    def validate_name(self, name):
        raise NotImplementedError(f"You must define this method on your {self.__class__.__name__} class.")

    def format_name(self, names):
        """
        Format a list of names. Suitable for overriding on subclasses, the default behaviour is to return a string
        consisting of all names separated by a space.

        Args:
            names (list): The list of generated names.

        Returns:
            string: The full name, in string format.
        """
        return ' '.join(names)

    def full_name(self, count=1):
        """
        Generate one or more full_names.

        Args:
            count (int): The number of names to generate.

        Yields:
            string: A formatted full name.
        """
        for _ in range(count):
            names = self._random_names()
            yield self.format_name(names)

    def _random_names(self):
        """
        Generate a random number of names.

        Returns:
            list (str): A list of randomly generated names.
        """
        full_name = []
        for i in range(self.number_of_names):
            full_name.append(self._get_name(self.syllable_template[i], self.syllable_weights[i]))
        return full_name

    def _get_name(self, template, weight):
        """
        Generate a single name using the specified syllable template and weights.

        Args:
            template (iter): An iterable of syllable templates, each one consisting of one or more template strings.
                Refer to the class docs for a description of possible templates.
            weight (iter): An iterable of syllable weights as integers. The number of elements in the iterable with
                non-zero weights determines the number of possible syllables in the name.

        Returns:
            string: A randomly-generated name that has passed validation.
        """
        name = ''
        while not name:
            for _ in range(self._random_syllable_count(weight)):
                name = name + self._make_syllable(template, weight)
            if name and self.validate_name(name):
                return name.capitalize()
            else:
                name = ''

    def _get_path(self, phoneme):
        return f"{self.data_path}/{self.__class__.__name__}_{phoneme}"

    def _load_graphemes(self):
        """
        Load data files and cache the language components.
        """
        with open(self._get_path('vowels')) as f:
            vowels = [l.strip() for l in f.readlines()]
            self._vowels = {
                'graphemes': vowels,
                'weights': [1 * len(v) for v in vowels],
                'pattern': re.compile(r'[' + r'|'.join(vowels) + r']')
            }
        with open(self._get_path('consonants')) as f:
            consonants = [l.strip() for l in f.readlines()]
            self._consonants = {
                'graphemes': consonants,
                'weights': [1 * len(c) for c in consonants],
                'pattern': re.compile(r'[' + r'|'.join(consonants) + r']')
            }
        self._load_affixes()

    def _load_affixes(self):
        """
        Load affixes, if they exist.
        """
        try:
            with open(self._get_path('affixes')) as f:
                affixes = [l.strip() for l in f.readlines()]
                self._affixes = {
                    'graphemes': affixes,
                    'weights': [1 for _ in affixes],
                    'pattern': re.compile(r'[' + r'|'.join(affixes) + r']')
                }
        except OSError:
            return

    def _random_syllable_count(self, weights):
        """
        Return a random number of syllables for a single name using the specified weights.
        """
        return 1 + random.choices(range(len(weights)), weights)[0]

    def _make_syllable(self, template, weight):
        """
        Generate a single syllable of a name, using syllable templates

        Args:
            template (iter): An iterable of syllable templates, each one consisting of one or more template strings.
                Refer to the class docs for a description of possible templates.
            weight (iter): An iterable of syllable weights as integers. The number of elements in the iterable with
                non-zero weights determines the number of possible syllables in the name.

        Returns:
            string: A syllable.
        """
        syllable = ''
        for part in template:
            syllable = syllable + self._random_grapheme(part)
        return syllable

    def _random_grapheme(self, phoneme_type):
        """
        Randomly choose a grapheme of the given type, weighted by length; graphemes of 2 characters are half as likely
        to be selected as graphemes of 1 character, and so on.

        Args:
            phoneme_type (str): The type of grapheme to select; 'c' or 'C' for a consonant, 'v' or 'V' for a vowel. The
                special values 'a' and 'A' can be used to select an affix, if available. If the phoneme_type is in
                lower-case, there is a 50% chance an empty string will ber returned instead of a grapheme.

        Returns:
            string: a grapheme of the specified type.
        """
        if phoneme_type.islower() and random.random() < 0.5:
            return ''
        pt = phoneme_type.lower()
        if pt == 'c':
            return random.choices(self._consonants['graphemes'], self._consonants['weights'])[0]
        elif pt == 'v':
            return random.choices(self._vowels['graphemes'], self._vowels['weights'])[0]
        elif pt == 'a':
            return random.choices(self._affixes['graphemes'], self._affixes['weights'])[0]
        raise Exception(f"Invalid phoneme type: {phoneme_type}")


class elf(NameGenerator):
    """
    Name generator for elven names. The language constructs are a derived from a combination of Tolkein's Quenya
    language and conventions developed in-game and based on twirrim's player character name.
    """
    number_of_names = 3
    syllable_template = ('c', 'V', 'c'), 'A', ('V', 'C')
    syllable_weights = [0, 1, 2], [1], [1, 2, 2]

    _valid_middle_clusters = re.compile(
        r'^\S?[cc|ht|hty|kd|kl|km|kp|kt|kv|kw|ky|lc|ld|lf|ll|lm|lp|lt|lv|lw|ly|mb|mm|mp|my|' +
        r'nc|nd|ng|ngw|nn|nt|nty|nw|ny|ps|pt|rc|rd|rm|rn|rp|rqu|rr|rs|rt|rty|rw|ry|sc|squ|ss|ts|tt|tw|ty]+\S?$'
    )

    def format_name(self, names):
        return ' '.join([names[0], names[1].lower(), names[2]])

    def validate_name(self, sequence):
        if sequence in self._affixes['graphemes']:
            return True
        return (
            self._validate_first_syllable(sequence) and
            self._validate_middle_clusters(sequence) and
            self._validate_last_syllable(sequence)
        )

    def _validate_first_syllable(self, sequence):

        # anything starting with a vowel is fine
        if self._vowels['pattern'].match(sequence[0]):
            return True

        # anything starting with these sequences is fine
        valid = re.compile(r'[ky|ty|ly|ny|nw]')
        if valid.match(sequence[:2]):
            return True

        # anything starting with one of these consonants followed by a vowel is fine
        if sequence[0] in 'cfhlmnpqrstvwy':
            if self._vowels['pattern'].match(sequence[1]):
                return True

        return False

    def _validate_last_syllable(self, sequence):
        valid = self._vowels['graphemes'] + ['t', 's', 'n', 'l', 'r']
        if sequence[-1] not in valid:
            return False
        return True

    def _validate_middle_clusters(self, sequence):
        last_consonant = ''
        for char in sequence:
            if char in self._vowels['graphemes']:
                last_consonant = ''
                continue
            if last_consonant:
                if not self._valid_middle_clusters.match(last_consonant + char):
                    return False
            last_consonant = char
        return True
